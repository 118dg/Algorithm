//동적계획법.. 너무 오랜만이라 좀 까먹었다
//공부한 걸 토대로 다음 주는 직접 풀어봐야겠다
//(1) 초기값을 setting 한다
//(2) ~ 일때 최대 개수 이런 식으로 dp를 짠다
//(3) 이 문제처럼 경우의 수가 3가지면 각각에 대해 dp를 짠다 (여기선 3차원 배열)
//예시로 초코 우유 마실 때 초코 우유 여기서 안 마시고 이전에 마셨던 상태로 냅둔 뒤 바나나 우유 먹는 경우에서 고려해줘서 +1 하는 거랑, 그냥 여기서 마시고 그 전에 딸기 우유 마셨던 경우에서 +1 하는 거랑
//둘 중 뭐가 더 큰지 이런 거 고려해주는 거 주의해야할 것 같다

/*
영학이는 딸기우유, 초코우유, 바나나우유를 좋아한다.

입맛이 매우 까다로운 영학이는 자신만의 우유를 마시는 규칙이 있다. 

맨 처음에는 딸기우유를 한 팩 마신다.
딸기우유를 한 팩 마신 후에는 초코우유를 한 팩 마신다.
초코우유를 한 팩 마신 후에는 바나나우유를 한 팩 마신다.
바나나우유를 한 팩 마신 후에는 딸기우유를 한 팩 마신다. 
저번 축제에서 수많은 우유를 마셨지만 더욱 우유에 갈증을 느낀 영학이는 우유 여행을 떠났다.

맛있는 우유를 찾아 떠난 영학이는 수많은 우유 가게로 둘러 쌓인 어느 도시에 도착했다.

이 도시는 정사각형 형태의 2차원 격자 모양으로 남북으로 N개, 동서로 N개, 총 N*N개의 우유 가게들이 있다.

영학이는 도시의 서북쪽 끝 (1, 1)에서 출발해서 동남쪽 아래 (N, N)까지 까지 가면서 우유를 사 마신다. 

각각의 우유 가게는 딸기, 초코, 바나나 중 한 종류의 우유만을 취급한다.

각각의 우유 가게 앞에서, 영학이는 우유를 사 마시거나, 사 마시지 않는다.

So cooooool~한 영학이는 오직 동쪽 또는 남쪽으로만 움직이기 때문에 한 번 지나친 우유 가게에는 다시 가지 않는다.

영학이가 마실 수 있는 우유의 최대 개수를 구하여라.
*/

import java.util.Scanner;

public class Main_14722 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		solve();
	}
	
	public static void solve() {
		Scanner sc = new Scanner(System.in);
		
	    int n = sc.nextInt(); //우유 도시의 크기 n * n
	    int[][] array = new int[n][n]; //어떤 우유 가게인지(input)
	    int[][][] dp = new int[n][n][3]; //dp[m][n][milk] = 좌표 (m,n) 가게까지 어떤 우유를 마셨을 때 우유의 최대 개수
	    
	    //어떤 우유 가게인지 array배열 값 입력 받기
	    for (int i = 0; i < n; i++) {
	        for (int j = 0; j < n; j++) {
	            array[i][j] = sc.nextInt();
	        }
	    }
	 
		//첫 번째 가게(0,0)에 대한 dp setting
	    if (array[0][0] == 0) { //만약 첫 번째 가게(0,0)가 딸기우유 가게라면
	        dp[0][0][0] = 1; //(0,0)가게까지 딸기 우유를 마셨을 때 우유의 최대 개수는 1
	    }
	 
	    // ------------------------ setting -----------------------------
	    for (int i = 1; i < n; i++) { //맨 첫 번째 가로줄 셋팅
	        int milk = array[0][i]; //(0,i) 가게가 어떤 우유 파는 가게인지
	 
	        dp[0][i][0] = milk == 0 ? dp[0][i - 1][2] + 1 : dp[0][i - 1][0]; 
		    //(1) (0,i)가게에서 딸기 우유를 먹을 경우,
		    // * 현재 방문한 가게가 딸기 우유파는 가게라면? 딸기 우유를 먹을 수 있다. 그 전 바나나 우유 먹었던 경우엔 우유 최대 개수 + 1,
		    // * 다른 가게라면? 딸기 우유를 먹을 수 없다. 따라서 (0,i-1) 가게까지 딸기 우유 마셨던 우유 최대 개수 넣는다.
		    //Q. 왜 하필 다른 가게인 경우 다른 우유도 아니고 딸기 우유에 대한 걸 넣는가? => dp[m][n][0] 은 딸기 우유에 대한 거니까.
	        dp[0][i][1] = milk == 1 && dp[0][i][2] < dp[0][i][0] ? dp[0][i - 1][0] + 1 : dp[0][i - 1][1];
		    //(2) (0,i)가게에서 초코 우유를 먹을 경우,
		    // * 현재 방문한 가게가 초코 우유파는 가게라면? 초코 우유를 먹을 수 있다. 
		    //이때, 이 가게에서 딸기 우유를 먹는 경우의 최대 개수가 여기서 바나나 우유 먹는 경우의 최대 개수보다 클 경우! 초코 우유를 먹는다, 즉 그 전 딸기 우유 먹었던 경우에 우유 최대 개수 + 1
		    //만약 이 가게에서 딸기 우유를 먹는 경우의 최대 개수보다 여기서 바나나 우유 먹는 경우의 최대 개수가 더 크다면! 그냥 여기서 초코 우유 안 먹고 이전에 초코 우유 먹은 상태인 dp[0][i-1][1] 값으로 유지한 다음에
		    //아래 바나나 우유 관련 코드에서 dap[0][i][2] = dp[0][i-1][1] + 1 값으로 넣어주는 게 더 최대가 되기 때문에 이렇게 고려해주는 것이다.
		    // * 다른 가게라면? 초코 우유를 먹을 수 없다. 따라서 (0,i-1) 가게까지 초코 우유 마셨던 우유 최대 개수 넣는다.
	        dp[0][i][2] = milk == 2 && dp[0][i][0] < dp[0][i][1] ? dp[0][i - 1][1] + 1 : dp[0][i - 1][2];
		    //(3) (0,i)가게에서 바나나 우유를 먹을 경우,
		    // * 현재 방문한 가게가 바나나 우유파는 가게라면? 바나나 우유를 먹을 수 있다. 
		    //이때, 이 가게에서 초코 우유를 먹는 경우의 최대 개수가 여기서 딸기 우유 먹는 경우의 최대 개수보다 클 경우! 바나나 우유를 먹는다, 즉 그 전 초코 우유 먹었던 경우에 우유 최대 개수 + 1
		    //만약 이 가게에서 초코 우유를 먹는 경우의 최대 개수보다 여기서 딸기 우유 먹는 경우의 최대 개수가 더 크다면! 그냥 여기서 바나나 우유 안 먹고 이전에 바나나 우유 먹은 상태인 dp[0][i-1][2] 값으로 유지한 다음에
		    //위 딸기 우유 관련 코드에서 dap[0][i][0] = dp[0][i-1][2] + 1 값으로 넣어주는 게 더 최대가 되기 때문에 이렇게 고려해주는 것이다.
		    // * 다른 가게라면? 바나나 우유를 먹을 수 없다. 따라서 (0,i-1) 가게까지 바나나 우유 마셨던 우유 최대 개수 넣는다.
	    }
	 
	    for (int i = 1; i < n; i++) { //맨 첫 번째 세로줄 셋팅
	        int milk = array[i][0]; //(i,0) 가게가 어떤 우유 파는 가게인지
	 
	        dp[i][0][0] = milk == 0 ? dp[i - 1][0][2] + 1 : dp[i - 1][0][0];
	        dp[i][0][1] = milk == 1 && dp[i][0][2] < dp[i][0][0] ? dp[i - 1][0][0] + 1 : dp[i - 1][0][1];
	        dp[i][0][2] = milk == 2 && dp[i][0][0] < dp[i][0][1] ? dp[i - 1][0][1] + 1 : dp[i - 1][0][2];
		//방법은 위와 동일!
	    }
	    // ---------------------------------------------------------------
	 
	    //나머지 줄에 대한 처리
	    for (int i = 1; i < n; i++) {
	        for (int j = 1; j < n; j++) {
	            int milk = array[i][j];
	 
	            dp[i][j][0] = milk == 0 //현재 방문한 가게가 딸기 우유 가게라면?
	                ? Math.max(dp[i][j - 1][2] + 1, dp[i - 1][j][2] + 1) //딸기 우유 섭취 가능. 위에서 바나나 우유 먹고 온 경우랑 왼쪽에서 바나나 우유 먹고 온 경우 중 최대 개수인 경우에 + 1 해서 넣기
	                : Math.max(dp[i][j - 1][0], dp[i - 1][j][0]); //아니라면? 딸기 우유 섭취 불가능. 그 전에 위에서 딸기 우유 먹은 경우랑 왼쪽에서 딸기 우유 먹은 경우 중 최대 개수인 경우의 값으로 넣기
	            
		    dp[i][j][1] = milk == 1 && dp[i][j][2] < dp[i][j][0] //방법은 위와 동일.
	                ? Math.max(dp[i][j - 1][0] + 1, dp[i - 1][j][0] + 1)
	                : Math.max(dp[i][j - 1][1], dp[i - 1][j][1]);
	 
	            dp[i][j][2] = milk == 2 && dp[i][j][0] < dp[i][j][1] //방법은 위와 동일.
	                ? Math.max(dp[i][j - 1][1] + 1, dp[i - 1][j][1] + 1)
	                : Math.max(dp[i][j - 1][2], dp[i - 1][j][2]);
	        }
	    }
	    System.out.println(Math.max(dp[n - 1][n - 1][0], Math.max(dp[n - 1][n - 1][1], dp[n - 1][n - 1][2])));
	    //맨 마지막 가게에서 각각 딸기/초코/바나나 우유를 먹게 되는 경우 중 우유 최대 개수가 가장 큰 경우의 값으로 출력
	}
}
